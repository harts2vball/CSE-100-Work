/*
 * Names: Yejia Zhang and Brian Ng
 * Date: 10/4/16
 * Filename: questions.txt
 * Description: Answers for PA questions.
 */

1) testBST.o, BSTInt.o BSTNodeInt.o

2) BSTInt.cpp:25:8: error: use of undeclared identifier 'root'
if (!root) {
       ^
BSTInt.cpp:26:5: error: use of undeclared identifier 'root'
    root = new BSTNodeInt(item);
    ^
BSTInt.cpp:27:7: error: use of undeclared identifier 'isize'
    ++isize;
      ^
BSTInt.cpp:31:22: error: use of undeclared identifier 'root'
  BSTNodeInt* curr = root;
                     ^
BSTInt.cpp:56:5: error: use of undeclared identifier 'isize'
  ++isize;
    ^
5 errors generated.
make: *** [BSTInt.o] Error 1

This error occurs because when the name scope is removed from the function, the compiler does not know that the function belongs to the BSTInt class. Thus, it cannot find the corresponding variables 'root' and 'isize', which are located in the BSTInt class. 

3) The bug was the use of the "&&" operator in the while loop condition in the insert function. This is wrong because both the right and left child do not always have to exist to traverse down the tree to find the appropriate location to place the new node.

4) First, we looked at the code to see if we could find the bug reasonably quickly. Due to the fishy nature of the while loop condition, we decided to run through and write out a quick example that might cause the insert method to behave incorrectly. We considered the case where the root node had only a left child and where a smaller integer than the root's data was inserted. Instead of inserting the new node at the appropriate place (attached as the left child of the left child of the node), the incorrectly written function would replace the root's left child with the new node instead. After confirming this example does indeed expose an error in the condition of the while loop, we verified it by writing a corresponding test in testBST.cpp and running it. To fix this, we first changed the '&&' operator in the while loop condition to '||' because both children do not necessarily have to exist for a traversal to happen. To compensate for this change, within each if statement comparing the item to the current node's data, we added an intermediate if-else statement to check if the corresponding right or left child really does exist. If it did exist, we traversed down that branch; else, we break out of the loop because we found the node at which to attach the new node to (there are no more nodes to traverse down).

5) BST's insert method's argument is pass by reference while BSTInt's insert method's argument is pass by value. BST's insert method doesn't use pass by value because BST can hold objects in which case passing by reference is more appropriate than pass by value. It doesn't make sense to pass objects by value, thereby duplicating memory, when objects can be passed by reference. On the other hand, BSTInt's insert method doesn't use pass by reference because it only holds primitive integer values, where pass by reference is unnecessary.

6) The sorted input file creates taller trees.

7) Given an input of N elements into the tree, the height we expect for the sorted input is N and the height we expect of the random input is log(N). We reason this becuse for an alphabetically sorted input, insert will continously add each new node to the right child of the leaf node of the tree, therefore mimicking a linked list structure, and resulting in a height of N. On the other hand, for unsorted random input, insert will place the node wherever it belongs at random, and although our tree is not self-balancing, this random input should generate a more balanced tree than the aforementioned one, resulting in a height closer to log(n). To test this, we built the tree with actors100.txt, then created an actors100_sorted.txt input file based off the first 100 lines of actors_sorted.txt. Our results matched our expectations: for a sample size of 100, the tree generated from unsorted input indiciated a height of 99 and the tree generated from sorted input indicated a height of 14, which is closer to log(100) ~ 7.